
local setmetatable=setmetatable
local clamp=clamp
local acos=math.acos
local sin=math.sin
local cos=math.cos
local sqrt=math.sqrt
local error=error
local min=math.min
local max=math.max
local abs=math.abs
local Time=UnityEngine.Time

local ToAngle=57.29578
local Epsilon=0.00001
local Infinite=1/0

local Raw=UnityEngine.Vector3
local Vector3={__typename="Vector3",__raw=Raw}
_G["UnityEngine.Vector3.Instance"]=Vector3
UnityEngine.Vector3=Vector3
local T=Vector3
local get={}
local set={}

Vector3.__index = function(t,k)
	local f=rawget(Vector3,k)
	if f then return f end
	local f=rawget(get,k)
	if f then return f(t) end
	error("Not found "..k)
end

Vector3.__newindex = function(t,k,v)
	local f=rawget(set,k)
	if f then return f(t,v) end
	error("Not found "..k)
end


Vector3.New=function (x,y,z)
	local v={x,y,z}
	return setmetatable(v,Vector3)
end

Vector3.__call = function(t,x,y,z)
	return T.New(x,y,z)
end

Vector3.__eq = function(a,b)
	return abs(a[1]-b[1])<Epsilon
	 	and abs(a[2]-b[2])<Epsilon
	 	and abs(a[3]-b[3])<Epsilon
end

Vector3.__unm = function(a)
	local ca=T.New(-a[1],-a[2],-a[3])
	return ca
end


Vector3.__tostring = function(self)
	return string.format("Vector3(%f,%f,%f)",self[1],self[2],self[3])
end

Vector3.__mul = function(a,b)
	return Vector3.New(a[1]*b,a[2]*b,a[3]*b)
end

Vector3.__add = function(a,b)
	return Vector3.New(a[1]+b[1],a[2]+b[2],a[3]+b[3])
end

Vector3.__sub = function(a,b)
	return Vector3.New(a[1]-b[1],a[2]-b[2],a[3]-b[3])
end

Vector3.__div = function(a,b)
	return Vector3.New(a[1]/b,a[2]/b,a[3]/b)
end

function Vector3.Mul(self,b)
	self[1],self[2],self[3]=self[1]*b,self[2]*b,self[3]*b
end

function Vector3.Add(self,b)
	self[1],self[2],self[3]=self[1]+b[1],self[2]+b[2],self[3]+b[3]
end

function Vector3.Sub(self,b)
	self[1],self[2],self[3]=self[1]-b[1],self[2]-b[2],self[3]-b[3]
end

function Vector3.Div(self,b)
	self[1],self[2],self[3]=self[1]/b,self[2]/b,self[3]/b
end


function get.back() return Vector3(0,0,-1) end
function get.down() return Vector3(0,-1,0) end
function get.forward() return Vector3(0,0,1) end
function get.left() return Vector3(-1,0,0) end
function get.one() return Vector3(1,1,1) end
function get.right() return Vector3(1,0,0) end
function get.up() return Vector3(0,1,0) end
function get.zero() return Vector3(0,0,0) end

function get:x() return self[1] end
function get:y() return self[2] end
function get:z() return self[3] end
function set:x(v) self[1]=v end
function set:y(v) self[2]=v end
function set:z(v) self[3]=v end
function get:magnitude() return Vector3.Magnitude(self) end
function get:sqrMagnitude() return Vector3.SqrMagnitude(self) end
function get:normalized() 
	local cv=self:Clone()
	T.Normalize(cv)
	return cv
end


function Vector3:Clone()
	return Vector3.New(self[1],self[2],self[3])
end
	
function Vector3:Set(x,y,z)	
	self[1],self[2],self[3]=x or 0,y or 0,z or 0
end

function Vector3:ToString()
	return self:__tostring()
end

function Vector3.Angle(a,b)
	local dot = Dot(T.Normalize(a), T.Normalize(b))
	return acos()*ToAngle
end

function Vector3.Normalize(v)
	local m = T.Magnitude(v)
	if m==1 then
		return v
	elseif m>Epsilon then
		v[1],v[2],v[3]=v[1]/m,v[2]/m,v[3]/m
	else
		v:Set(0,0,0)
	end
end

function Vector3.Magnitude(v)
	return sqrt(v[1]^2+v[2]^2+v[3]^2)
end

function Vector3.SqrMagnitude(v)
	return v[1]^2+v[2]^2+v[3]^2
end

function Vector3.Dot(a,b)
	return a[1]*b[1] + a[2]*b[2] + a[3]*b[3]
end

function Vector3.Cross(a,b)
	return T.New((a[2] * b[3]) - (a[3] * b[2])
		, (a[3] * b[1]) - (a[1] * b[3])
		, (a[1] * b[2]) - (a[2] * b[1]))
end

function Vector3.Slerp(a,b,t)
	if t<=0 then return T.Clone(a) end
	if t>=1 then return T.Clone(b) end

	local dot=Vector3.Dot(a,b)
	dot=clamp(dot,-1,1)
	local theta = acos(dot)*t
	a=T.Clone(a)
	b=T.Clone(b)
	local v=T.Clone(a)

	T.Mul(v,dot)
	T.Sub(b,v)
	T.Normalize(b)
	T.Mul(b,sin(theta))	
	T.Mul(a,cos(theta))
	T.Add(a,b)

	return a
end

function Vector3.Lerp(a,b,t)
	return T.New(a[1]+(b[1]-a[1])*t
		,a[2]+(b[2]-a[2])*t
		,a[3]+(b[3]-a[3])*t
	)
end

function Vector3.Min(a,b)
	return T.New(min(a[1],b[1])
		,min(a[2],b[2])
		,min(a[3],b[3]))
end

function Vector3.Max(a,b)
	return T.New(max(a[1],b[1])
		,max(a[2],b[2])
		,max(a[3],b[3]))
end

function Vector3.MoveTowards(a,b,adv)
	local v = T.__sub(b,a)
	local m = T.Magnitude(v)
	if m>adv and m~=0 then
		T.Div(v,m)
		T.Mul(v,adv)
		T.Add(v,a)
		return v
	end
	return T.Clone(b)
end

-- TODO
function Vector3.RotateTowards(a,b,angle,mag)
	return Raw.RotateTowards(a,b,angle,mag)
end

function Vector3.Distance(a,b)
	a=T.Clone(a)
	T.Sub(a,b)
	return T.Magnitude(a)
end

function Vector3.OrthoNormalize(u,v,w)
	T.Normalize(u)

	local dot0 = T.Dot(u,v)
	local tu=T.Clone(u)
	T.Mul(tu,dot0)
	T.Sub(v,tu)
	T.Normalize(v)

	if w then
		local dot1 = T.Dot(v,w)
		local dot0 = T.Dot(u,w)
		local tw=T.__mul(u,dot0)
		local tv=T.__mul(v,dot1)
		T.Add(tv,tw)
		T.Sub(w,tv)
		T.Normalize(w)
	end
end

function Vector3.Scale(a,b)
	return Vector3.New(a[1]*b[1],a[2]*b[2],a[3]*b[3])
end

-- code copy from reflactor of UnityEgnine
function Vector3.SmoothDamp(current,target,currentVelocity,smoothTime,maxSpeed,deltaTime)
	local deltaTime = deltaTime or Time.deltaTime
	local maxSpeed = maxSpeed or Infinite
	smoothTime = max(Epsilon,smoothTime)
	local float num = 2 / smoothTime
    local float num2 = num * deltaTime
    local float num3 = 1 / (((1 + num2) + ((0.48 * num2) * num2)) + (((0.235 * num2) * num2) * num2))
    local vector = current - target;
    local vector2 = target
    local maxLength = maxSpeed * smoothTime
    vector = T.ClampMagnitude(vector, maxLength)
    target = current - vector
    local vector3 = currentVelocity +  vector * deltaTime * num
    local newv = currentVelocity -  vector3 * num3 * num
    local vector4 = target + (vector + vector3) * num3
    if T.Dot(vector2 - current, vector4 - vector2) > 0 then
        vector4 = vector2
        newv = (vector4 - vector2) / deltaTime
    end
    currentVelocity:Set(newv.x,newv.y,newv.z)
    return vector4
end

-- code copy from reflactor of UnityEgnine
function Vector3.ClampMagnitude(vector,maxLength)
    if T.SqrMagnitude(vector) > (maxLength^2) then
        return vector.normalized * maxLength
    end
    return T.Clone(vector)
end

function Vector3.Reflect(dir,nml)
	local dot=T.Dot(nml,dir)*-2
	local v=T.__mul(nml,dot)
	T.Add(v,dir)
	return v
end

-- code copy from reflactor of UnityEgnine
function Vector3.ProjectOnPlane(vector,planeNormal)
	return vector - T.Project(vector, planeNormal)
end

-- code copy from reflactor of UnityEgnine
function Vector3.Project( vector,normal )
	local num = T.Dot(normal, normal)
    if num < Epsilon then
        return Vector3.zero
    end
    return (normal * T.Dot(vector, normal)) / num
end

setmetatable(Vector3,Vector3)